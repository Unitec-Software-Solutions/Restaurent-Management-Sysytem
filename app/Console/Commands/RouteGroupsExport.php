<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Services\RouteGroupService;
use Illuminate\Support\Facades\File;

class RouteGroupsExport extends Command
{
    protected $signature = 'route:groups:export 
                            {--output= : Output directory for route group files}
                            {--format=php : Export format (php, json, markdown)}';

    protected $description = 'Export organized route groups to files';

    protected RouteGroupService $routeGroupService;

    public function __construct(RouteGroupService $routeGroupService)
    {
        parent::__construct();
        $this->routeGroupService = $routeGroupService;
    }

    public function handle()
    {
        $this->info('ðŸš€ Exporting Route Groups...');
        $this->newLine();

        $outputPath = $this->option('output') ?: base_path('routes/groups');
        $format = $this->option('format');

        // Create output directory
        if (!File::isDirectory($outputPath)) {
            File::makeDirectory($outputPath, 0755, true);
            $this->info("ðŸ“ Created output directory: {$outputPath}");
        }

        // Get organized routes
        $organized = $this->routeGroupService->organizeRoutes();
        $exported = [];

        foreach ($organized as $group => $routes) {
            if (empty($routes)) {
                continue;
            }

            $filename = $this->exportGroup($group, $routes, $outputPath, $format);
            if ($filename) {
                $exported[] = $filename;
                $this->line("âœ… Exported {$group}: " . count($routes) . " routes â†’ {$filename}");
            }
        }

        // Export health report
        $healthReport = $this->routeGroupService->generateGroupHealthReport();
        $healthFile = $this->exportHealthReport($healthReport, $outputPath, $format);
        if ($healthFile) {
            $exported[] = $healthFile;
            $this->line("ðŸ“Š Exported health report â†’ {$healthFile}");
        }

        // Export suggestions
        $suggestions = $this->routeGroupService->suggestReorganization();
        $suggestionsFile = $this->exportSuggestions($suggestions, $outputPath, $format);
        if ($suggestionsFile) {
            $exported[] = $suggestionsFile;
            $this->line("ðŸ’¡ Exported suggestions â†’ {$suggestionsFile}");
        }

        $this->newLine();
        $this->info("ðŸŽ‰ Export complete! Generated " . count($exported) . " files.");
        
        if (!empty($suggestions)) {
            $this->newLine();
            $this->warn("âš ï¸  Found " . count($suggestions) . " reorganization suggestions:");
            foreach ($suggestions as $suggestion) {
                $severity = $suggestion['severity'] === 'high' ? 'ðŸ”´' : 'ðŸŸ¡';
                $this->line("  {$severity} {$suggestion['message']}");
            }
        }

        return 0;
    }

    protected function exportGroup(string $group, array $routes, string $outputPath, string $format): ?string
    {
        $filename = null;

        switch ($format) {
            case 'php':
                $filename = "{$outputPath}/{$group}.php";
                $content = $this->generatePhpContent($group, $routes);
                break;
            
            case 'json':
                $filename = "{$outputPath}/{$group}.json";
                $content = json_encode($routes, JSON_PRETTY_PRINT);
                break;
            
            case 'markdown':
                $filename = "{$outputPath}/{$group}.md";
                $content = $this->generateMarkdownContent($group, $routes);
                break;
            
            default:
                $this->error("Unsupported format: {$format}");
                return null;
        }

        File::put($filename, $content);
        return $filename;
    }

    protected function generatePhpContent(string $group, array $routes): string
    {
        $header = "<?php\n\n";
        $header .= "// {$group} routes - Generated by RouteGroupsExport\n";
        $header .= "// Generated on: " . date('Y-m-d H:i:s') . "\n";
        $header .= "// Total routes: " . count($routes) . "\n\n";
        $header .= "use Illuminate\Support\Facades\Route;\n\n";

        $groupMacro = $this->getGroupMacro($group);
        
        if ($groupMacro) {
            $content = $header . "Route::{$groupMacro}(function () {\n";
            foreach ($routes as $route) {
                $method = strtolower($route['methods'][0]);
                $uri = $this->stripGroupPrefix($route['uri'], $group);
                $action = $route['action'];
                $name = $this->stripGroupPrefix($route['name'], $group);

                $content .= "    Route::{$method}('{$uri}', {$action})->name('{$name}');\n";
            }
            $content .= "});\n";
        } else {
            $content = $header;
            foreach ($routes as $route) {
                $method = strtolower($route['methods'][0]);
                $uri = $route['uri'];
                $action = $route['action'];
                $name = $route['name'];
                $middleware = !empty($route['middleware']) ? "->middleware(['" . implode("', '", $route['middleware']) . "'])" : '';

                $content .= "Route::{$method}('{$uri}', {$action}){$middleware}->name('{$name}');\n";
            }
        }

        return $content;
    }

    protected function generateMarkdownContent(string $group, array $routes): string
    {
        $content = "# " . ucfirst($group) . " Routes\n\n";
        $content .= "Generated on: " . date('Y-m-d H:i:s') . "\n";
        $content .= "Total routes: " . count($routes) . "\n\n";

        $content .= "| Method | URI | Name | Action | Middleware |\n";
        $content .= "|--------|-----|------|--------|-----------|\n";

        foreach ($routes as $route) {
            $method = implode(', ', $route['methods']);
            $uri = $route['uri'];
            $name = $route['name'];
            $action = $route['action'];
            $middleware = implode(', ', $route['middleware']);

            $content .= "| {$method} | {$uri} | {$name} | {$action} | {$middleware} |\n";
        }

        return $content;
    }

    protected function exportHealthReport(array $healthReport, string $outputPath, string $format): ?string
    {
        $filename = "{$outputPath}/health_report.{$format}";

        switch ($format) {
            case 'json':
                $content = json_encode($healthReport, JSON_PRETTY_PRINT);
                break;
            
            case 'markdown':
                $content = $this->generateHealthMarkdown($healthReport);
                break;
            
            case 'php':
                $content = "<?php\n\nreturn " . var_export($healthReport, true) . ";\n";
                break;
            
            default:
                return null;
        }

        File::put($filename, $content);
        return $filename;
    }

    protected function exportSuggestions(array $suggestions, string $outputPath, string $format): ?string
    {
        if (empty($suggestions)) {
            return null;
        }

        $filename = "{$outputPath}/suggestions.{$format}";

        switch ($format) {
            case 'json':
                $content = json_encode($suggestions, JSON_PRETTY_PRINT);
                break;
            
            case 'markdown':
                $content = $this->generateSuggestionsMarkdown($suggestions);
                break;
            
            case 'php':
                $content = "<?php\n\nreturn " . var_export($suggestions, true) . ";\n";
                break;
            
            default:
                return null;
        }

        File::put($filename, $content);
        return $filename;
    }

    protected function generateHealthMarkdown(array $healthReport): string
    {
        $content = "# Route Health Report\n\n";
        $content .= "Generated on: " . date('Y-m-d H:i:s') . "\n\n";

        foreach ($healthReport as $group => $data) {
            $content .= "## " . ucfirst($group) . " Group\n\n";
            $content .= "- **Total Routes**: " . $data['total_routes'] . "\n";
            $content .= "- **Middleware Coverage**: " . $data['middleware_coverage']['percentage'] . "%\n";
            $content .= "- **Naming Consistency**: " . $data['naming_consistency']['percentage'] . "%\n\n";
            
            if (!empty($data['naming_consistency']['issues'])) {
                $content .= "### Naming Issues\n\n";
                foreach ($data['naming_consistency']['issues'] as $issue) {
                    $content .= "- `{$issue['route']}` should start with `{$issue['expected_prefix']}`\n";
                }
                $content .= "\n";
            }
        }

        return $content;
    }

    protected function generateSuggestionsMarkdown(array $suggestions): string
    {
        $content = "# Route Reorganization Suggestions\n\n";
        $content .= "Generated on: " . date('Y-m-d H:i:s') . "\n\n";

        $high = array_filter($suggestions, fn($s) => $s['severity'] === 'high');
        $medium = array_filter($suggestions, fn($s) => $s['severity'] === 'medium');

        if (!empty($high)) {
            $content .= "## High Priority\n\n";
            foreach ($high as $suggestion) {
                $content .= "### {$suggestion['group']} - {$suggestion['type']}\n";
                $content .= $suggestion['message'] . "\n\n";
            }
        }

        if (!empty($medium)) {
            $content .= "## Medium Priority\n\n";
            foreach ($medium as $suggestion) {
                $content .= "### {$suggestion['group']} - {$suggestion['type']}\n";
                $content .= $suggestion['message'] . "\n\n";
            }
        }

        return $content;
    }

    protected function getGroupMacro(string $group): ?string
    {
        $macros = [
            'admin' => 'adminGroup',
            'organization' => 'organizationGroup',
            'branch' => 'branchGroup',
            'api' => 'apiGroup',
            'guest' => 'guestGroup',
        ];

        return $macros[$group] ?? null;
    }

    protected function stripGroupPrefix(string $value, string $group): string
    {
        $prefix = $group . '.';
        if (str_starts_with($value, $prefix)) {
            return substr($value, strlen($prefix));
        }
        return $value;
    }
}
